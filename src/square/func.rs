use std::ops::RangeInclusive;

use ndarray::{
    Array2,
    s,
};

/// A vector of `RangeInclusive` up to `n` that produces similarly sized trapizoid slices.
/// 
/// For an example array of 20x20 (`n`=20) with `count`=4, this function will return the
/// following Groups in a `Vec<RangeInclusive<usize>>`.
/// 
///     Group 1: 0..=9,   consisting of 45 items.
///     Group 2: 10..=13, consisting of 46 items.
///     Group 3: 14..=17, consisting of 62 items.
///     Group 4: 18..=19, consisting of 37 items.
///     
///     [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
///      [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
///      [1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
///      [1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
///      [1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
///      [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
///      [1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
///      [1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
///      [1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
///      [1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
///      [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
///      [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0],
///      [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0, 0],
///      [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 0, 0, 0, 0, 0, 0, 0],
///      [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0, 0],
///      [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0, 0],
///      [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0, 0],
///      [3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 0, 0, 0],
///      [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0, 0],
///      [4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 4, 0]]
pub fn trapizoid_slices_of_lower_half(n:usize, count:usize) -> Vec<RangeInclusive<usize>> {
    let mut result:Vec<RangeInclusive<usize>> = Vec::new();

    let mut n0 = 0_usize;
    let area = (n*n) as f64 / 2. / count as f64;
    
    while n0 < n {
        let n0d = {
            (n0.pow(2) as f64 + 2. * area).sqrt()
            - n0 as f64
        }.round() as usize;

        let n1 = (n0 + n0d as usize).max(n0).min(n-1);
    
        result.push(n0..=n1);
        
        n0 = n1+1;
    }

    return result;
}

/// Mirror the values of the array in place along the diagonal.
/// 
/// For example, when we have derived a lower-half array like::
/// 
///     [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
///      [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
///      [1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
///      [1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
///      [1, 2, 3, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
///      [1, 2, 3, 4, 5, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
///      [1, 2, 3, 4, 5, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
///      [1, 2, 3, 4, 5, 6, 7, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
///      [1, 2, 3, 4, 5, 6, 7, 8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
///      [1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
///      [2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
///      [2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0],
///      [2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 0, 0, 0, 0, 0, 0, 0, 0],
///      [2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 0, 0, 0, 0, 0, 0, 0],
///      [3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 0, 0, 0, 0, 0, 0],
///      [3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 0, 0, 0, 0, 0],
///      [3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 0, 0, 0, 0],
///      [3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 0, 0],
///      [4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 0, 0],
///      [4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 0]]
///     
/// This function will clone the lower-left half to the upper-right half of the
/// array::
/// 
///     [[0, 2, 1, 0, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 9, 8, 7, 6, 5, 4],
///      [1, 0, 1, 0, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 9, 8, 7, 6, 5, 4],
///      [1, 2, 0, 9, 8, 7, 6, 5, 4, 3, 2, 1, 0, 9, 8, 7, 6, 5, 4, 3],
///      [1, 2, 3, 0, 8, 7, 6, 5, 4, 3, 2, 1, 0, 9, 8, 7, 6, 5, 4, 3],
///      [1, 2, 3, 4, 0, 7, 6, 5, 4, 3, 2, 1, 0, 9, 8, 7, 6, 5, 4, 3],
///      [1, 2, 3, 4, 5, 0, 6, 5, 4, 3, 2, 1, 0, 9, 8, 7, 6, 5, 4, 3],
///      [1, 2, 3, 4, 5, 6, 0, 4, 3, 2, 1, 0, 9, 8, 7, 6, 5, 4, 3, 2],
///      [1, 2, 3, 4, 5, 6, 7, 0, 3, 2, 1, 0, 9, 8, 7, 6, 5, 4, 3, 2],
///      [1, 2, 3, 4, 5, 6, 7, 8, 0, 2, 1, 0, 9, 8, 7, 6, 5, 4, 3, 2],
///      [1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 0, 9, 8, 7, 6, 5, 4, 3, 2],
///      [2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 0, 9, 8, 7, 6, 5, 4, 3, 2, 1],
///      [2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 0, 8, 7, 6, 5, 4, 3, 2, 1],
///      [2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 0, 7, 6, 5, 4, 3, 2, 1],
///      [2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 0, 6, 5, 4, 3, 2, 1],
///      [3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 0, 5, 4, 3, 2, 1],
///      [3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 0, 4, 3, 2, 1],
///      [3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 0, 3, 2, 1],
///      [3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 2, 1],
///      [4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 0, 1],
///      [4, 5, 6, 7, 8, 9, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 0, 1, 2, 0]]
pub fn mirror_along_diagonal<A>(arr: &mut Array2<A>)
where   A: Clone {
    assert_eq!(
        arr.shape()[0],
        arr.shape()[1],
        "mirror_along_diagonal only accepts square arrays, yet input array is shaped {:?}.",
        arr.shape(),
    );

    let size = arr.shape()[0];

    {
        (1..size)
        .into_iter()
        .for_each(
            | idx | {
                let from_s = s![idx, 0..idx];
                let to_s = s![size-idx-1, (size-idx)..size; -1];

                // This cloning is unavoidable and intentional - afterall we ARE cloning part of
                // the array to another!
                let cloned_slice = arr.slice(from_s).to_owned();

                arr.slice_mut(to_s)
                   .assign(&cloned_slice);
            }
        )
    }
}